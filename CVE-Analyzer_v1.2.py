import os
import yaml
import pandas as pd
from tqdm import tqdm
import datetime
import logging
import requests
import re
import time
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication

# API Constants
API_BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
API_KEY_FILE_PATH = os.path.join(os.getcwd(), "api_key.txt")
CONFIG_FILE_PATH = os.path.join(os.getcwd(), "date.yaml")

"""
Initialize Logger
Useful for DevSecOps monitoring and debugging
"""
# Create a logger
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Create a file handler and set level to info
file_handler = logging.FileHandler("analyzer.log")
file_handler.setLevel(logging.INFO)

# Create a console handler and set level to info
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)

# Create formatter
formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")

# Add formatter to the handlers
file_handler.setFormatter(formatter)
console_handler.setFormatter(formatter)

# Add handlers to the logger
logger.addHandler(file_handler)
logger.addHandler(console_handler)

"""Functions"""


# Create a default configuration YAML file
# Used to store the last execution date to fetch CVEs from NVD
def create_default_config():
    date_90_days_ago = (datetime.datetime.now() - datetime.timedelta(days=90)).strftime('%Y-%m-%d')
    config = {"LastRunDate": date_90_days_ago}

    with open(CONFIG_FILE_PATH, "w") as config_file:
        yaml.safe_dump(config, config_file)


# Fetch the last execution date from the YAML configuration file
def get_last_run_date():
    with open(CONFIG_FILE_PATH, "r") as config_file:
        config = yaml.safe_load(config_file)
    return config.get("LastRunDate", "")


# Update the last execution date in the YAML configuration file
def set_last_run_date(date_str):
    with open(CONFIG_FILE_PATH, "r") as config_file:
        config = yaml.safe_load(config_file) or {}
    config["LastRunDate"] = date_str
    with open(CONFIG_FILE_PATH, "w") as config_file:
        yaml.safe_dump(config, config_file)


def make_api_request(base_url, headers, query_params, max_retries=3):
    """Make an API request with retry mechanism."""
    retries = 0
    while retries <= max_retries:
        try:
            response = requests.get(base_url, headers=headers, params=query_params)
            response.raise_for_status()

            if response.status_code == 200:
                return response.json()
            else:
                response.raise_for_status()

        except requests.RequestException as e:
            retries += 1
            if retries > max_retries:
                logger.error(f"Error fetching data from API after {max_retries} retries: {e}")
                return None
            logger.warning(f"Request failed, retrying... ({retries}/{max_retries})")

    return None


# Fetch latest CVEs based on date range and CPE product version by Published Date
def get_latest_cves_by_published_date(api_key, cpe_product_version):
    headers = {"User-Agent": "Python Script", "API-Key": api_key}

    last_run_date = get_last_run_date() + "T00:00:00Z"
    end_date = datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S') + "Z"

    cves_data = []
    page = 1
    results_per_page = 2000

    while True:
        query_params = {
            "cpeName": cpe_product_version,
            "startIndex": (page - 1) * results_per_page,
            "resultsPerPage": results_per_page,
            "pubStartDate": last_run_date,
            "pubEndDate": end_date,
        }

        page_data = make_api_request(API_BASE_URL, headers, query_params)

        if page_data:
            current_cves = page_data.get("vulnerabilities", [])
            if current_cves:
                logging.info(f"CVEs Found by Published Date! Retrieving Page {page} for {cpe_product_version}")
                cves_data.extend(current_cves)
                page += 1
            else:
                break
        else:
            break
    return cves_data


# Fetch latest CVEs based on date range and CPE product version by Modified Date
def get_latest_cves_by_modified_date(api_key, cpe_product_version):
    headers = {"User-Agent": "Python Script", "API-Key": api_key}

    last_run_date = get_last_run_date() + "T00:00:00Z"
    end_date = datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S') + "Z"

    cves_data = []
    page = 1
    results_per_page = 2000

    while True:
        query_params = {
            "cpeName": cpe_product_version,
            "startIndex": (page - 1) * results_per_page,
            "resultsPerPage": results_per_page,
            "lastModStartDate": last_run_date,
            "lastModEndDate": end_date
        }

        page_data = make_api_request(API_BASE_URL, headers, query_params)
        if page_data:
            current_cves = page_data.get("vulnerabilities", [])
            if current_cves:
                logging.info(f"CVEs Found by Modified Date! Retrieving Page {page} for {cpe_product_version}")
                cves_data.extend(current_cves)
                page += 1
            else:
                break
        else:
            break
    return cves_data


def get_latest_cves_with_date_range(api_key, cpe_product_version):
    cves_by_published_date = get_latest_cves_by_published_date(api_key, cpe_product_version)
    cves_by_modified_date = get_latest_cves_by_modified_date(api_key, cpe_product_version)

    # Combine and deduplicate
    combined_cves = {cve['cve']['id']: cve for cve in cves_by_published_date}
    for cve in cves_by_modified_date:
        cve_id = cve['cve']['id']
        if cve_id not in combined_cves:
            combined_cves[cve_id] = cve

    return list(combined_cves.values())


"""Utility functions"""


# These functions are critical for CPE (Common Platform Enumeration) string parsing and validation
def extract_vendor_product_version(cpe_string):
    # Split the CPE string by its colon delimiter
    parts = cpe_string.split(":")

    # Ensure there are enough parts
    if len(parts) < 7:
        return cpe_string, "", ""  # Return original string and empty values for product and version

    vendor, product, version = parts[3], parts[4], parts[5]
    return vendor, product, version


def is_valid_cpe(cpe_string):
    pattern = r'^cpe:/?[aoh]?(:[A-Za-z0-9\._\-~%]+)*$'
    return bool(re.match(pattern, cpe_string))


# Truncate and sanitize the sheet name
def sanitize_sheet_name(cpe_string):
    # Extract vendor, product, and version from the CPE string
    vendor, product, version = extract_vendor_product_version(cpe_string)

    # Combine vendor, product, and version with underscores
    sanitized_name = "_".join(filter(None, [vendor, product, version]))

    max_length = 31
    # Further sanitize by removing any non-alphanumeric characters (other than underscores)
    sanitized_name = "".join(c for c in sanitized_name if c.isalnum() or c == '_')

    # Ensure the sheet name doesn't exceed the max length.
    if len(sanitized_name) > max_length:
        short_hash = str(hash(sanitized_name))[:5]
        sanitized_name = sanitized_name[:max_length - len(short_hash) - 1] + "_" + short_hash

    return sanitized_name


# Generate Excel report from CVE data.
def generate_xlsx_with_progress(cpe_product_version, cves_data, writer):
    data = []
    for cve_item in cves_data:
        row = {
            "CVE ID": cve_item["cve"]["id"],
            "Description": cve_item["cve"]["descriptions"][0]["value"],
            "Published Date": pd.to_datetime(cve_item["cve"]["published"]),
            "Modified Date": pd.to_datetime(cve_item["cve"]["lastModified"]),  # New field
            "URL": f"https://nvd.nist.gov/vuln/detail/{cve_item['cve']['id']}"
        }

        # Add CVSS scores to the dictionary
        for version in ["cvssMetricV2", "cvssMetricV30", "cvssMetricV31"]:
            score = "N/A"
            metrics = cve_item["cve"]["metrics"].get(version, [])
            if metrics:
                score = metrics[0]["cvssData"].get("baseScore", "N/A")
            row[version + " Score"] = score

        data.append(row)  # Add the dictionary to the list

    # Convert the list of dictionaries to a DataFrame
    df = pd.DataFrame(data, columns=["CVE ID", "Description", "cvssMetricV2 Score", "cvssMetricV30 Score",
                                     "cvssMetricV31 Score", "Published Date", "Modified Date",
                                     "URL"])  # Added "Modified Date"

    # Sort the DataFrame by "Published Date" in descending order (newest to oldest)
    df = df.sort_values(by="Published Date", ascending=False)

    # Sanitize the CPE product version to create a valid sheet name
    sanitized_cpe_product_version = sanitize_sheet_name(cpe_product_version)

    # Write the DataFrame to a new worksheet with the sanitized CPE product version as the sheet name
    df.to_excel(writer, sheet_name=sanitized_cpe_product_version, index=False)

    worksheet = writer.sheets[sanitized_cpe_product_version]

    # Setting fixed widths for these columns, you can optimize these further
    widths = {
        'A:A': 15,
        'B:B': 30,
        'C:C': 20,
        'D:D': 20,
        'E:E': 20,
        'F:F': 20,
        'G:G': 20,
        'H:H': 60
    }

    for column, width in widths.items():
        worksheet.set_column(column, width)

    # Conditional formatting of worksheet "yellow"
    if not df.empty:
        worksheet.set_tab_color('#FFFF00')


def get_api_key_from_file():
    """
    Retrieve the API key from api_key.txt or prompt the user for it.
    """
    try:
        if os.path.exists(API_KEY_FILE_PATH) and os.path.getsize(API_KEY_FILE_PATH) > 0:
            with open(API_KEY_FILE_PATH, "r") as file:
                return file.readline().strip()
        else:
            return request_api_key()
    except Exception as ex:
        logger.error(f"Error retrieving API key: {ex}")
        raise


def request_api_key():
    user_api_key = input("Enter your NVD API Key: ").strip()  # Renamed the local variable
    store_api_key_to_file(user_api_key)
    return user_api_key


def store_api_key_to_file(key):  # Changed parameter name here as well
    """
    Store the provided API key to api_key.txt.
    """
    with open("api_key.txt", "w") as file:
        file.write(key)


def send_email(report_filename, total_cves, last_scan_date):
    # Read email addresses from email_list.txt
    with open("email_list.txt", "r") as f:
        email_addresses = f.read().splitlines()

    # Read SMTP configuration from smtp_config.yaml
    with open("smtp_config.yaml", "r") as f:
        smtp_config = yaml.safe_load(f)

    # Email content
    subject = f"[CVE-Analyzer] {report_filename}"
    body = f"""The CVE Analyzer has identified {total_cves} CVEs since {last_scan_date}.


    This is an automated email message sent from CVE Analyzer. Do not reply to this email."""

    # SMTP Configuration
    smtp_server = smtp_config.get("smtp_server", "")
    smtp_port = smtp_config.get("smtp_port", 587)
    smtp_username = smtp_config.get("smtp_username", "")
    smtp_password = smtp_config.get("smtp_password", "")

    # Create the email
    msg = MIMEMultipart()
    msg["From"] = smtp_username
    msg["To"] = ", ".join(email_addresses)
    msg["Subject"] = subject
    msg.attach(MIMEText(body, "plain"))

    # Attach the report
    with open(report_filename, "rb") as f:
        attach = MIMEApplication(f.read(), Name=report_filename)
    attach["Content-Disposition"] = f"attachment; filename={report_filename}"
    msg.attach(attach)

    # Attach the analyzer.log
    log_filename = "analyzer.log"
    with open(log_filename, "rb") as f:
        attach_log = MIMEApplication(f.read(), Name=log_filename)
    attach_log["Content-Disposition"] = f"attachment; filename={log_filename}"
    msg.attach(attach_log)

    # Send the email
    try:
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(smtp_username, smtp_password)
        server.sendmail(smtp_username, email_addresses, msg.as_string())
        server.quit()
        logger.info("Email sent successfully.")
    except Exception as e:
        logger.error(f"Failed to send email: {e}")


# Initialize a flag to track if any CVEs are found
cve_found = False

if __name__ == "__main__":
    try:
        if not os.path.exists(CONFIG_FILE_PATH):
            create_default_config()

        nvd_api_key = get_api_key_from_file()

        # Fetch the last scan date
        last_scan_date = get_last_run_date()

        # Display and log the initialization message
        init_message = (f'Initializing Vulnerability Analyzer for CVEs against NVD from: {last_scan_date}'
                        f'...')
        logger.info(init_message)

        # Pause for 3 seconds
        time.sleep(3)

        with open("cpe_versions.txt", "r") as cpe_file:
            cpe_versions = cpe_file.read().splitlines()

        current_date = datetime.date.today().strftime("%Y-%m-%d")
        yellow_sheets_data = {}  # To store data for yellow sheets
        other_sheets_data = {}  # To store data for other sheets
        total_cves_across_all_versions = 0  # Initialize the total CVE counter

        for current_cpe_version in cpe_versions:
            current_fetched_cves_data = get_latest_cves_with_date_range(nvd_api_key, current_cpe_version)

            # Update the flag if any CVEs are found
            if current_fetched_cves_data:
                cve_found = True

            sanitized_cpe_product_version = sanitize_sheet_name(current_cpe_version)

            total_cves = len(current_fetched_cves_data)
            total_cves_across_all_versions += total_cves  # Update the total CVE counter

            if not current_fetched_cves_data:  # If no CVEs are found, the sheet will not be yellow
                other_sheets_data[sanitized_cpe_product_version] = current_fetched_cves_data
            else:
                yellow_sheets_data[sanitized_cpe_product_version] = current_fetched_cves_data

            progress_bar = tqdm(total=total_cves, desc=f"Processing {current_cpe_version}", unit="CVE")
            progress_bar.update(total_cves)
            progress_bar.close()
            logging.info(f"Processed {len(current_fetched_cves_data)} CVEs for {current_cpe_version}\n")

        # Conditionally set the workbook name based on the flag
        final_workbook_name = ""
        if cve_found:
            final_workbook_name = f"CVE-FOUND_REPORT_({current_date}).xlsx"
        else:
            final_workbook_name = f"CVE-EMPTY_REPORT_({current_date}).xlsx"

        output_workbook = pd.ExcelWriter(final_workbook_name, engine="xlsxwriter")

        # First, write yellow sheets
        for sheet_name, data in yellow_sheets_data.items():
            generate_xlsx_with_progress(sheet_name, data, output_workbook)

        # Then, write other sheets
        for sheet_name, data in other_sheets_data.items():
            generate_xlsx_with_progress(sheet_name, data, output_workbook)

        logging.info(f"Total number of CVEs found: {total_cves_across_all_versions}")

        set_last_run_date(datetime.date.today().strftime("%Y-%m-%d"))

        # Close the final workbook
        output_workbook.close()
        logging.info(f"Excel file '{final_workbook_name}' has been generated.")

        # Send the email with the generated report
        send_email(final_workbook_name, total_cves_across_all_versions, last_scan_date)

    except Exception as exc:
        logger.error(f"Unexpected error: {exc}")
